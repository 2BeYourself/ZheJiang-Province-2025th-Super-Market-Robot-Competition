# RT-Thread机器人项目 - 对话总结

**日期**: 2026-01-16
**项目**: Robtic_V3.1 (赛场初版本)
**主题**: 项目概览与超声波模块代码分析

---

## 📋 一、项目整体概况

### 1.1 项目基本信息

- **项目名称**: RTT-Robotic-Project (超市机器人挑战赛)
- **版本**: Robtic_V3.1 (赛场初版本 v1.0)
- **主控芯片**: STM32F103ZET6 (Cortex-M3, 72MHz, 512KB Flash, 64KB RAM)
- **操作系统**: RT-Thread 4.1.1
- **开发环境**: RT-Thread Studio (基于Eclipse)
- **构建系统**: SCons

### 1.2 核心功能模块

| 模块 | 硬件 | 接口 | 功能 |
|------|------|------|------|
| **电机控制** | Emm25 V5.0 ×4 | UART4 | 四轮独立闭环驱动 |
| **机械臂** | LX-16A ×3 | UART3 | 3自由度抓取系统 |
| **陀螺仪** | HWT101 | UART2 | 9轴姿态融合 |
| **超声波** | HC-SR04 ×4 | GPIO | 距离检测避障 |
| **视觉** | YOLO模块 | UART | 物品识别定位 |
| **编码器** | AB相 | TIM1/5/8 | 速度反馈 |

### 1.3 目录结构

```
RTT-Robotic-Project/
├── applications/              # 应用层代码 (231KB)
│   ├── arm/                  # 机械臂控制
│   ├── motor/                # 电机控制
│   ├── gyro/                 # 陀螺仪模块
│   ├── task/                 # 任务管理
│   ├── competition/          # 比赛流程控制
│   ├── yolo_comm/            # 视觉通信
│   ├── ultrasonic_ver2.0/    # 超声波模块 ⭐
│   ├── PID/                  # PID算法
│   └── main.c
├── drivers/                  # BSP驱动层 (383KB)
├── cubemx/                   # STM32CubeMX配置
├── libraries/                # STM32 HAL库
├── rt-thread/                # RT-Thread内核 (27MB)
└── 说明书/                   # 硬件协议文档
```

---

## 🔍 二、超声波模块详细分析

### 2.1 文件信息

**位置**: `applications/ultrasonic_ver2.0/`
- **头文件**: `ultrasonic.h` (52行)
- **源文件**: `ultrasonic.c` (223行)

### 2.2 硬件配置

#### 引脚定义 (GPIO端口G)

```c
/* 触发引脚 - 输出模式 */
PIN_TRIG_FRONT   GET_PIN(G,0)  // 前方
PIN_TRIG_RIGHT   GET_PIN(G,1)  // 右侧
PIN_TRIG_BACK    GET_PIN(G,2)  // 后方
PIN_TRIG_LEFT    GET_PIN(G,3)  // 左侧

/* 回波引脚 - 输入+中断模式 */
PIN_ECHO_FRONT   GET_PIN(G,4)  // 前方
PIN_ECHO_RIGHT   GET_PIN(G,5)  // 右侧
PIN_ECHO_BACK    GET_PIN(G,6)  // 后方
PIN_ECHO_LEFT    GET_PIN(G,7)  // 左侧
```

#### 通道编号

```c
US_CHANNEL_FRONT   (0)  // 前方
US_CHANNEL_RIGHT   (1)  // 右侧
US_CHANNEL_BACK    (2)  // 后方
US_CHANNEL_LEFT    (3)  // 左侧
```

### 2.3 核心技术实现

#### 2.3.1 测距原理

```
触发脉冲(10µs) → 发送超声波 → 障碍物反射 → Echo回波脉冲

距离计算公式：
  脉冲宽度 = t_end - t_start (微秒)
  距离 = pulse_width × 0.0343 cm/µs / 2
       = pulse_width × 0.01715 cm
```

**测量范围**: 2cm ~ 400cm
**对应时间**: 116µs ~ 23320µs (约23ms)

#### 2.3.2 中断捕获机制

**关键函数**: `echo_irq()` (ultrasonic.c:89-108)

```c
static void echo_irq(void *args)
{
    int idx = (int)(uintptr_t)args;  // 传感器索引

    if (上升沿 && 等待上升沿状态) {
        t_start[idx] = TIM2计数器值;  // 记录开始时间
        rt_sem_release(&sem_start[idx]);
        echo_state[idx] = 1;  // 状态切换
    }
    else if (下降沿 && 等待下降沿状态) {
        t_end[idx] = TIM2计数器值;    // 记录结束时间
        rt_sem_release(&sem_end[idx]);
        echo_state[idx] = 0;  // 重置状态
    }
}
```

**技术要点**:
- 使用**双边沿中断** (PIN_IRQ_MODE_RISING_FALLING)
- **信号量同步** - sem_start和sem_end用于线程间通信
- **TIM2作为1µs基准时钟** - 需要CubeMX配置(PSC=71)

#### 2.3.3 中位值滤波算法

**关键函数**: `apply_median_filter()` (ultrasonic.c:33-65)

```c
#define ULTRASONIC_FILTER_SAMPLES 5  // 滤波窗口大小

实现步骤:
1. 将新样本存入环形缓冲区
2. 检查缓冲区是否已填满(预热期)
3. 复制样本到临时数组
4. 使用qsort排序
5. 返回sorted_samples[2] (中位数)
```

**滤波效果**:
- ✅ 有效去除脉冲噪声和异常值
- ⚠️ 引入约2个采样周期的延迟(200ms)
- ⚠️ 预热期前5次采样未滤波(500ms)

#### 2.3.4 测量线程主循环

**关键函数**: `ultrasonic_thread_entry()` (ultrasonic.c:111-173)

```c
while (1) {
    for (int i = 0; i < 4; i++) {  // 轮询4个通道

        // ① 发送触发脉冲 (10µs)
        rt_pin_write(trig_pins[i], PIN_HIGH);
        rt_hw_us_delay(10);
        rt_pin_write(trig_pins[i], PIN_LOW);

        // ② 等待回波 (超时60ms)
        if (rt_sem_take(&sem_start[i], 60ms) != RT_EOK ||
            rt_sem_take(&sem_end[i],   60ms) != RT_EOK) {
            rt_kprintf("传感器 %d 测量超时\n", i);
            continue;  // 跳过本次测量
        }

        // ③ 计算距离并滤波
        pulse_width = t_end - t_start;
        raw_distance = pulse_width * 0.01715f;
        us_distance_cm[i] = apply_median_filter(i, raw_distance);
    }

    // ④ 打印结果
    rt_kprintf("通道[0]:%d.%02dcm  ...\n", ...);

    rt_thread_mdelay(100);  // 100ms后下一轮
}
```

**性能参数**:
- 测量频率: ~10Hz (每100ms一轮)
- 单通道测量周期: 100ms
- 超时保护: 60ms

### 2.4 全局数据接口

```c
volatile float us_distance_cm[4];  // 单位: 厘米

// 访问方式:
// us_distance_cm[0] - 前方距离
// us_distance_cm[1] - 右侧距离
// us_distance_cm[2] - 后方距离
// us_distance_cm[3] - 左侧距离
```

### 2.5 初始化流程

**关键函数**: `ultrasonic_init()` (ultrasonic.c:176-219)

```c
初始化步骤:
1. 创建4对信号量 (sem_start, sem_end)
2. 配置GPIO模式 (Trig输出, Echo输入下拉)
3. 绑定中断回调函数
4. 启动TIM2定时器 (1µs基准)
5. 创建测量线程 (优先级12, 栈1024字节)
6. 自动初始化 (INIT_APP_EXPORT)
```

---

## ✅ 三、代码优点总结

| 特性 | 说明 | 代码位置 |
|------|------|----------|
| **环形缓冲区** | 固定5样本窗口，内存高效 | ultrasonic.c:8-12 |
| **中位值滤波** | 比均值滤波更抗噪声 | ultrasonic.c:33-65 |
| **双边沿中断** | 精确捕获脉冲宽度 | ultrasonic.c:89-108 |
| **溢出处理** | 处理TIM2计数器溢出 | ultrasonic.c:146-148 |
| **超时机制** | 60ms超时避免阻塞 | ultrasonic.c:132-140 |
| **预热期处理** | 缓冲区未填满时返回原始值 | ultrasonic.c:51-53 |
| **线程安全** | 信号量同步中断和线程 | ultrasonic.c:71-72 |
| **自动初始化** | INIT_APP_EXPORT宏 | ultrasonic.c:222 |

---

## ⚠️ 四、潜在问题与建议

### 4.1 超时处理策略

**问题代码** (ultrasonic.c:138-139):
```c
rt_kprintf("传感器 %d 测量超时\n", i);
continue;  // 跳过本次循环
```

**问题**: 超时后`us_distance_cm[i]`保留上一次的旧值，可能导致避障误判

**建议修改**:
```c
// 方案1: 设置无效值标记
us_distance_cm[i] = -1.0f;  // 或 999.0f

// 方案2: 保留上一次值但增加超时计数器
static uint8_t timeout_count[4] = {0};
timeout_count[i]++;
if (timeout_count[i] > 3) {
    us_distance_cm[i] = 999.0f;  // 连续超时标记为无效
}
```

### 4.2 滤波预热期处理

**问题代码** (ultrasonic.c:51-52):
```c
if (!ultrasonic_buffer_filled[sensor_id])
    return raw_distance;  // 直接返回原始值
```

**影响**: 系统启动前500ms数据未滤波，可能导致误触发

**建议修改**:
```c
// 方案1: 返回部分数据的平均值
int count = ultrasonic_sample_index[sensor_id];
if (count > 0) {
    float sum = 0;
    for (int i = 0; i < count; i++) {
        sum += ultrasonic_sample_buffer[sensor_id][i];
    }
    return sum / count;
}

// 方案2: 返回中位值(对已排序的部分数据)
```

### 4.3 定时器溢出处理边界条件

**当前代码** (ultrasonic.c:146-148):
```c
pulse_width_us = (htim2.Instance->ARR - t_start[i]) + t_end[i] + 1;
```

**分析**: 如果回波时间超过ARR值(65535µs ≈ 65ms)会溢出

**实际情况**: 超时60ms已覆盖，不会触发此情况，代码安全 ✅

### 4.4 打印输出优化

**当前代码** (ultrasonic.c:160-168):
```c
for (int i = 0; i < US_CHANNEL_NUM; i++) {
    rt_kprintf("通道[%d]:%d.%02dcm  ", i, integer_part, fractional_part);
}
rt_kprintf("\r\n");
```

**建议**: 注释掉调试打印，或通过宏开关控制
```c
#ifdef ULTRASONIC_DEBUG
    rt_kprintf("通道[%d]:%d.%02dcm  ", ...);
#endif
```

---

## 📊 五、性能参数总结

| 参数 | 数值 | 说明 |
|------|------|------|
| **测量范围** | 2cm ~ 400cm | HC-SR04标准量程 |
| **测量频率** | ~10Hz | 每100ms一轮 |
| **单通道周期** | 100ms | 包含触发+等待+计算 |
| **滤波延迟** | ~200ms | 5样本中位值滤波 |
| **超时时间** | 60ms | 覆盖最大量程 |
| **定时器精度** | 1µs | 基于TIM2 |
| **线程优先级** | 12 | RT-Thread优先级 |
| **线程栈大小** | 1024字节 | |
| **通道数量** | 4 | 前后左右 |

---

## 🎯 六、模块依赖关系

```
ultrasonic模块依赖:
├── RT-Thread内核
│   ├── 线程管理 (rt_thread_xxx)
│   ├── 信号量 (rt_sem_xxx)
│   └── GPIO设备 (rt_pin_xxx)
├── HAL库
│   └── TIM2定时器 (HAL_TIM_Base_Start)
└── 标准库
    └── qsort (中位值滤波排序)

被以下模块使用:
├── motor/       - 避障控制
├── task/        - 货架对齐
└── competition/ - 比赛决策
```

---

## 📝 七、后续建议

### 7.1 代码优化
1. **添加错误码机制** - 用特殊值标记无效测量
2. **优化预热期处理** - 使用部分数据计算
3. **添加宏开关** - 控制调试打印输出
4. **增加单元测试** - 验证滤波算法正确性

### 7.2 功能增强
1. **动态测量频率** - 根据障碍物距离调整
2. **自适应滤波** - 根据环境噪声调整窗口大小
3. **数据校验** - 添加合理性检查(如突变检测)
4. **历史数据记录** - 用于轨迹分析

### 7.3 文档完善
1. **添加使用示例** - 其他模块如何调用
2. **时序图说明** - 测量流程可视化
3. **故障排查指南** - 常见问题解决方案

---

## 🔗 八、相关文件

- **硬件协议**: `说明书/` 目录下的PDF文档
- **主程序**: `applications/main.c`
- **电机控制**: `applications/motor/`
- **任务模块**: `applications/task/`
- **比赛控制**: `applications/competition/`

---

## 📌 九、关键代码索引

| 功能 | 文件 | 行号 |
|------|------|------|
| 中断捕获 | ultrasonic.c | 89-108 |
| 中位值滤波 | ultrasonic.c | 33-65 |
| 测量线程 | ultrasonic.c | 111-173 |
| 初始化函数 | ultrasonic.c | 176-219 |
| 引脚定义 | ultrasonic.h | 23-39 |
| 全局距离数组 | ultrasonic.c | 68 |

---

**总结人**: Claude Code Assistant
**文档版本**: v1.0
**最后更新**: 2026-01-16
