# Emm25 步进驱动器带应答确认命令使用说明

## 📋 功能概述

新增的带应答确认命令（`*_ack` 后缀）实现了：
- **发送命令并等待驱动器应答**
- **自动重试机制**（可配置重试次数）
- **详细的错误报告**（通过串口输出）

---

## 🔧 核心函数

### `send_frame_with_ack()`

**函数原型**：
```c
static rt_err_t send_frame_with_ack(const uint8_t *buf, size_t len, uint8_t max_retry)
```

**参数**：
- `buf`：命令缓冲区
- `len`：命令长度
- `max_retry`：最大重试次数
  - `0` = 无限重试直到成功
  - `3` = 重试3次后放弃
  - 建议值：3

**返回值**：
- `RT_EOK`：收到正确应答（状态码 0x02）
- `-RT_ETIMEOUT`：超时未收到应答
- `-RT_ERROR`：收到错误应答

**应答格式**（4字节）：
```
| 地址 | 功能码 | 状态码 | 校验字节 |
```

**状态码含义**：
| 状态码 | 含义 | 处理方式 |
|--------|------|----------|
| `0x02` | 成功 | ✅ 停止发送，返回成功 |
| `0xE2` | 条件不满足（堵转保护/电机未使能） | ❌ 打印错误，重试 |
| `0xEE` | 错误命令 | ❌ 打印错误，重试 |
| 其他 | 未知状态 | ❌ 打印错误，重试 |

---

## 📚 API 函数列表

### 1️⃣ **速度模式控制（带应答）**

```c
rt_err_t motor_cmd_speed_ack(uint8_t addr,
                             uint8_t dir,
                             uint16_t rpm,
                             uint8_t accel,
                             uint8_t sync_flag,
                             uint8_t max_retry);
```

**参数说明**：
- `addr`：电机地址（0x01-0x04 为42电机，0x05 为57电机）
- `dir`：方向（0x00=CW顺时针, 0x01=CCW逆时针）
- `rpm`：速度（0-3000 RPM）
- `accel`：加速度档位（0=不使用曲线加减速）
- `sync_flag`：同步标志（0=立即执行，1=等待同步命令）
- `max_retry`：最大重试次数（0=无限，建议3）

---

### 2️⃣ **位置模式控制（带应答）**

```c
rt_err_t motor_cmd_position_ack(uint8_t addr,
                                uint8_t dir,
                                uint16_t rpm,
                                uint8_t accel,
                                uint32_t pulses,
                                uint8_t rel_abs,
                                uint8_t sync_flag,
                                uint8_t max_retry);
```

**额外参数**：
- `pulses`：脉冲数（3200脉冲=1圈，16细分）
- `rel_abs`：位置模式（0x00=相对位置，0x01=绝对位置）

---

### 3️⃣ **立即停止命令（带应答）**

```c
rt_err_t motor_cmd_stop_ack(uint8_t addr,
                            uint8_t sync_flag,
                            uint8_t max_retry);
```

---

### 4️⃣ **多机同步运动（带应答）**

```c
rt_err_t motor_cmd_sync_ack(uint8_t max_retry);
```

---

## 🧪 使用示例

### **示例 1：控制升降电机（带重试）**

```c
#include "motor/Inc/motor_cmd.h"

/* 升降台上升，自动重试直到成功 */
rt_err_t result = motor_cmd_speed_ack(0x05,      // 地址：57电机
                                      CW,        // 方向：顺时针
                                      100,       // 速度：100 RPM
                                      0,         // 加速度：不使用曲线加减速
                                      0,         // 同步标志：立即执行
                                      3);        // 重试3次

if (result == RT_EOK)
{
    rt_kprintf("升降台上升成功！\n");
}
else
{
    rt_kprintf("升降台上升失败！\n");
}
```

**预期输出**：
```
[Motor] CMD F6 OK (addr=05)
升降台上升成功！
```

或（如果发生错误）：
```
[Motor] CMD F6 FAIL: 条件不满足 (堵转保护/电机未使能) (addr=05)
[Motor] Retrying...
[Motor] CMD F6 OK (addr=05)
升降台上升成功！
```

---

### **示例 2：多机同步控制（带重试）**

```c
/* 1. 发送四轮速度命令（sync_flag=1，暂不执行） */
motor_cmd_speed(LF, CW, 100, 0, 1);   // 左前轮
motor_cmd_speed(RF, CCW, 100, 0, 1);  // 右前轮
motor_cmd_speed(LB, CW, 100, 0, 1);   // 左后轮
motor_cmd_speed(RB, CCW, 100, 0, 1);  // 右后轮

/* 2. 发送同步启动命令（等待应答） */
rt_err_t result = motor_cmd_sync_ack(3);  // 重试3次

if (result == RT_EOK)
{
    rt_kprintf("四轮同步启动成功！\n");
}
```

**预期输出**：
```
[Motor] CMD FF OK (addr=00)
四轮同步启动成功！
```

---

### **示例 3：位置模式控制（带重试）**

```c
/* 旋转2圈（3200 × 2 = 6400脉冲） */
rt_err_t result = motor_cmd_position_ack(0x05,      // 地址
                                          CCW,       // 逆时针
                                          100,       // 100 RPM
                                          0,         // 不使用曲线加减速
                                          6400,      // 6400脉冲
                                          Relative,  // 相对位置
                                          0,         // 立即执行
                                          3);        // 重试3次

if (result == RT_EOK)
{
    rt_kprintf("位置控制成功！\n");
}
```

**预期输出**：
```
[Motor] CMD FD OK (addr=05)
位置控制成功！
```

---

## 🔄 重试机制流程

```
发送命令
    ↓
等待应答（50ms超时）
    ↓
┌─────────────────────────────┐
│  收到应答？                  │
└─────────────────────────────┘
    ↓ Yes          ↓ No
校验应答帧        超时处理
    ↓                  ↓
┌─────────────────────────────┐
│  状态码是什么？              │
└─────────────────────────────┘
    ↓
┌─────────┬─────────┬─────────┐
│ 0x02   │ 0xE2   │ 0xEE   │
│ 成功   │ 条件   │ 错误   │
│        │ 不满足 │ 命令   │
└─────────┴─────────┴─────────┘
    ↓          ↓          ↓
  返回      打印错误    打印错误
  RT_EOK   并重试      并重试
            ↓            ↓
         达到最大      达到最大
         重试次数？    重试次数？
            ↓            ↓
        是→放弃     是→放弃
        否→继续     否→继续
```

---

## 📊 时序分析

### **单次命令发送时序**

```
0ms     2ms     52ms    62ms    72ms
|-------|--------|-------|-------|
  发送   DMA完成   等待    重试   重试
  命令   (2ms)    应答    延时    发送
  (忽略)          (50ms   (10ms)
              超时)
```

**关键时间点**：
- **0ms**：发送命令
- **2ms**：DMA发送完成（13字节 × 10位 ÷ 115200 ≈ 1.13ms）
- **2-52ms**：等待应答（50ms超时）
- **52ms**：超时，触发重试
- **52-62ms**：重试延时10ms（避免连续发送过快）
- **62ms**：发送第2次命令

---

## ⚠️ 注意事项

### 1️⃣ **不要在高频状态机中使用带应答的命令**

❌ **错误用法**（会导致状态机卡顿）：
```c
void motor_state_poll(void)
{
    case ST_UP:
        // ❌ 每次调用都要等待50ms应答，会导致状态机卡顿
        motor_cmd_speed_ack(0x05, CW, 100, 0, 0, 3);
        break;
}
```

✅ **正确用法**（使用不带应答的版本）：
```c
void motor_state_poll(void)
{
    case ST_UP:
        // ✅ 不等待应答，快速返回
        motor_cmd_speed(0x05, CW, 100, 0, 0);
        break;
}
```

---

### 2️⃣ **带应答命令适用于主动调用场景**

✅ **推荐使用场景**：
- FinSH 命令手动控制
- 初始化时的校准操作
- 关键动作的确认（如抓取、放置）

✅ **示例**：
```c
/* FinSH 命令：上升100 RPM，自动重试直到成功 */
static void msh_elevator_up_safe(int argc, char *argv[])
{
    uint16_t rpm = 100;
    if (argc > 1) rpm = atoi(argv[1]);

    rt_err_t result = motor_cmd_speed_ack(0x05, CW, rpm, 0, 0, 3);

    if (result == RT_EOK)
    {
        rt_kprintf("[Elevator] 上升成功 (RPM=%u)\n", rpm);
    }
    else
    {
        rt_kprintf("[Elevator] 上升失败，请检查电机连接！\n");
    }
}
MSH_CMD_EXPORT(msh_elevator_up_safe, msh_elevator_up_safe [rpm] - 安全上升(带应答确认));
```

---

### 3️⃣ **UART4 必须使能 DMA RX**

确保 `board.h` 中已配置：
```c
#define BSP_USING_UART4
#define BSP_UART4_RX_USING_DMA   // ✅ 必须使能（接收应答）
#define BSP_UART4_TX_USING_DMA   // ✅ 已使能（高效发送）
```

---

## 🧪 测试步骤

### **步骤 1：编译并烧录**
```bash
scons -c && scons
```

### **步骤 2：打开串口控制台**
- 波特率：115200
- 数据位：8
- 停止位：1

### **步骤 3：测试基本命令**

```bash
# 测试1：升降台上升（带应答）
msh_elevator_up_safe 100
# 预期输出：
# [Motor] CMD F6 OK (addr=05)
# [Elevator] 上升成功 (RPM=100)

# 测试2：立即停止（带应答）
msh_elevator_stop_safe
# 预期输出：
# [Motor] CMD FE OK (addr=05)
# [Elevator] 停止成功

# 测试3：多机同步（带应答）
# 先发送四轮速度命令（sync_flag=1）
# 再调用同步命令
motor_cmd_sync_ack(3)
# 预期输出：
# [Motor] CMD FF OK (addr=00)
```

---

## 🐛 故障排查

### **问题 1：一直显示超时**

**现象**：
```
[Motor] CMD F6 Timeout (retry=1/3, addr=05)
[Motor] CMD F6 Timeout (retry=2/3, addr=05)
[Motor] CMD F6 Timeout (retry=3/3, addr=05)
[Motor] Max retry reached, give up.
```

**可能原因**：
1. UART4 RX DMA 未使能
2. 电机地址不匹配
3. 串口波特率不对（应为 115200）
4. 电机未通电或未使能

**解决方法**：
```bash
# 1. 检查配置
# board.h 中应该有：
#define BSP_UART4_RX_USING_DMA   ✅
#define BSP_UART4_TX_USING_DMA   ✅

# 2. 检查电机地址（通过 DIP 开关）
# 42电机：LF=0x01, RF=0x02, LB=0x03, RB=0x04
# 57电机：0x05

# 3. 使用示波器或逻辑分析仪检查 UART4 信号
# PC10(TX), PC11(RX)
```

---

### **问题 2：显示条件不满足**

**现象**：
```
[Motor] CMD F6 FAIL: 条件不满足 (堵转保护/电机未使能) (addr=05)
```

**可能原因**：
1. 电机未使能
2. 触发堵转保护
3. 电机过流保护

**解决方法**：
```bash
# 1. 检查电机使能信号
# 2. 检查电机负载是否过大
# 3. 检查电机电流是否正常
```

---

## 📌 总结

### ✅ **优势**

| 特性 | 不带应答 | 带应答（新） |
|------|---------|-------------|
| **可靠性** | ❌ 低（发送后不管） | ✅ 高（自动重试） |
| **错误诊断** | ❌ 无法确认 | ✅ 详细错误报告 |
| **适用场景** | 高频状态机 | 关键操作 |
| **响应时间** | 快（2ms） | 慢（52ms/次，最多 156ms） |

### 🎯 **使用建议**

| 场景 | 推荐函数 | 原因 |
|------|---------|------|
| 状态机轮询（20Hz） | `motor_cmd_speed()` | 快速响应，不阻塞 |
| FinSH 手动控制 | `motor_cmd_speed_ack()` | 确保执行成功 |
| 初始化校准 | `motor_cmd_position_ack()` | 可靠性优先 |
| 紧急停止 | `motor_cmd_stop_ack()` | 必须确认成功 |

---

## 📞 技术支持

如有问题，请检查：
1. UART4 配置是否正确
2. 电机地址是否匹配
3. 串口波特率是否为 115200
4. 电机是否通电并使能

参考文档：
- `Emm_V5.0步进闭环驱动说明书Rev1.3.pdf`
- `motor/Inc/motor_cmd.h` - API 函数声明
- `motor/Src/motor_cmd.c` - 实现代码
